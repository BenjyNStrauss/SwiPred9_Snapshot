package install;

import utilities.LocalToolBase;

/**
 * 
 * @author Benjamin Strauss
 * verifyFolder
 *
 */

public class PerlScriptManager extends LocalToolBase {
	private static final String JPRED_FILENAME = DirectoryManager.FILES_PREDICT_JPRED+"/jpredapi";
	private static final String JPRED_SCRIPT = "#!/usr/bin/env perl \n"
			+ "use strict;\n"
			+ "use warnings;\n"
			+ "\n"
			+ "# Author: Alexey Drozdetskiy \n"
			+ "# Email: a.drozdetskiy@dundee.ac.uk\n"
			+ "# ---\n"
			+ "# Dr. Alexey Drozdetskiy\n"
			+ "# Senior Postdoctoral Research Assistant\n"
			+ "# The Barton Group\n"
			+ "# Division of Computational Biology\n"
			+ "# College of Life Sciences\n"
			+ "# University of Dundee, DD1 5EH, Dundee, Scotland, UK.\n"
			+ "# Tel:+44 1382 88731\n"
			+ "# www.compbio.dundee.ac.uk\n"
			+ "# The University of Dundee is registered Scottish charity: No.SC015096\n"
			+ "\n"
			+ "# Please contact me with suggestions to improve/fix client/server part of the JPred API. \n"
			+ "# Do not assume it's OK to modify the API and to try your version on live JPred installation. \n"
			+ "# Users abusing JPred servers effectively preventing others from using the service will be banned.\n"
			+ "\n"
			+ "# For documentation: run jpredapi without arguments like so: 'perl jpredapi'\n"
			+ "# JPred API tutorial is available at: http://www.compbio.dundee.ac.uk/jpred4/api.shtml\n"
			+ "\n"
			+ "use constant JPRED4  => 'http://www.compbio.dundee.ac.uk/jpred4';\n"
			+ "use constant HOST    => 'http://www.compbio.dundee.ac.uk/jpred4/cgi-bin/rest';\n"
			+ "use constant VERSION => 'v.1.5';\n"
			+ "\n"
			+ "use HTTP::Request;\n"
			+ "use HTTP::Request::Common;\n"
			+ "use LWP::UserAgent;\n"
			+ "\n"
			+ "# A handy shortcut for building a quick-and-dirty command-line interface\n"
			+ "sub subcommand($$) {\n"
			+ "    my ($expected, $code) = @_;\n"
			+ "    if ($expected eq $ARGV[0]) {\n"
			+ "        shift @ARGV;\n"
			+ "        $code->();\n"
			+ "        exit;\n"
			+ "    }\n"
			+ "}\n"
			+ "\n"
			+ "# A shortcut for outputting errors\n"
			+ "sub barf($) {\n"
			+ "    my $response = shift;\n"
			+ "    my ($message) = $response->content =~ m{<p>([^<]+)</p>};\n"
			+ "    die \"ERROR: $message\\n\";\n"
			+ "}\n"
			+ "\n"
			+ "my $ua = LWP::UserAgent->new;\n"
			+ "\n"
			+ "my $minInterval = 10; # IMPORTANT: please don't decrease this constant. Users abusing JPred server will be banned.\n"
			+ "\n"
			+ "my $checkVersion = $ua->request(GET HOST.'/version');\n"
			+ "if ($checkVersion->is_success) {\n"
			+ "    #print $checkVersion->content;\n"
			+ "    if ($checkVersion->content =~ /VERSION=(v\\.[0-9]*.[0-9]*)/) {\n"
			+ "	if ($1 ne VERSION) {\n"
			+ "	    print \"\\n\\n\\n********************************* WARNING: *********************************\\n\";\n"
			+ "	    print \"\\nThe jpredapi script version is out of date.\\nPlease download the up to date version at the following link:\\nhttp://www.compbio.dundee.ac.uk/jpred4/downloads/jpredapi.tar.gz\\n\";\n"
			+ "	    print \"\\nPausing for 20 sec to allow you to read the warning.\\n\";\n"
			+ "	    print \"\\n****************************************************************************\\n\\n\\n\";\n"
			+ "	    sleep(20);\n"
			+ "	}\n"
			+ "    }\n"
			+ "}\n"
			+ "\n"
			+ "\n"
			+ "if ($#ARGV == -1 || $ARGV[0] eq '-h' || $ARGV[0] eq 'help' || ($ARGV[0] ne 'status' && $ARGV[0] ne 'submit' && $ARGV[0] ne 'quota' && $ARGV[0] ne 'sectonewday')) {\n"
			+ "    doc();\n"
			+ "    exit();\n"
			+ "}\n"
			+ "\n"
			+ "sub doc {\n"
			+ "    my $doc = <<END;\n"
			+ "\n"
			+ "    JPred RESTful API client v.1.5 documentation.\n"
			+ "\n"
			+ "    General: \n"
			+ "	please note that jobs run through this client program will be submitted to the JPred 4 server:\n"
			+ "        http://www.compbio.dundee.ac.uk/jpred4\n"
			+ "\n"
			+ "    A tutorial about the JPred API is available at:\n"
			+ "        http://www.compbio.dundee.ac.uk/jpred4/api.shtml\n"
			+ "\n"
			+ "    Email: \n"
			+ "	Usage of your email address is optional on single sequence job submission, but if you use one  - you will be\n"
			+ "	notified when the job is complete or sent some diagnostics if it crashed. Email is obligatory for batch job submission. \n"
			+ "	Results from batch submissions are sent by email and link to individual job results and to an archive containing ALL results.\n"
			+ "	If you use email for your submissions we may ocassionaly contact you about major updates to the JPred server and JPred API.\n"
			+ "\n"
			+ "    ========== COMMANDS ==========\n"
			+ "\n"
			+ "  1.\n"
			+ "    To print this documentation run jpredapi without arguments like so:\n"
			+ "       'perl jpredapi'\n"
			+ "\n"
			+ "\n"
			+ "  2.\n"
			+ "    To submit a JPred job do:	\n"
			+ "       'perl jpredapi submit file=filename mode=batch format=fasta email=name\\@domain.com name=my_test_job skipPDB=on'\n"
			+ "    or\n"
			+ "       'perl jpredapi submit mode=single format=raw email=name\\@domain.com name=my_test_job skipPDB=on seq=MQVWPIEGIKKFETLSYLPPLTVEDLLKQIEYLLRSKWVPCLEFSKVGFVYRENHRSPGYYDGRYWTMWKLPMFGCTDATQVLKELEEAKKAYPDAFVRIIGFDNVRQVQLISFIAYKPPGC'\n"
			+ "    where:\n"
			+ "       'file=filename' - filename is the name of a file with the job input, see example_submission_sequence.txt (file name/suffix could be any, e.g. it does not have to be something like name.fasta for FASTA format file)\n"
			+ "       'seq=AAAABBB' - instead of passing input file, for one-sequence submission you can submit jobs with sequences passed right through command line\n"
			+ "       'format=batch' - defines format. Possible values are: \n"
			+ "          - batch (multiple sequence submission, file in FASTA format)\n"
			+ "          - seq (single sequence submission in raw/FASTA format)\n"
			+ "          - or multiple sequence submission formats: msf, blc, fasta\n"
			+ "       'email=name\\@domain.com' - defines email address where job report will be sent (optional for all but batch submissions). We DO recommend to use email.\n"
			+ "       'name=my_test_job_number_3' - defines (optional) job name\n"
			+ "       'skipPDB=on' - possible values are: on and off. If on - PDB check will not be performed - this is default for JPred API (see JPred documentation for more details on PDB check). Since default is defined, parameter is optional.\n"
			+ "    \n"
			+ "    NOTE: \n"
			+ "       order of parameters is not important, optional parameters could be left out.\n"
			+ "    NOTE: \n"
			+ "       adding the word 'silent' to the command line will suppress all but essential output, e.g.:\n"
			+ "       'perl jpredapi submit file=filename mode=batch format=fasta email=name\\@domain.com name=my_test_job skipPDB=on silent'\n"
			+ "  \n"
			+ "  2.1 \n"
			+ "    Check submission_all_types_example.csh script file provided for further examples.\n"
			+ "\n"
			+ "  2.2\n"
			+ "    Check *.example files for example of inputs in all valid combinations of mode/format: batch_fasta.example, msa_blc.example, msa_fasta.example, msa_msf.example, single_fasta.example, single_raw.example\n"
			+ "\n"
			+ "  2.2.1 \n"
			+ "    Valid combinations of mode/format are: mode=single format=raw, mode=single format=fasta, mode=msa format=fasta, mode=msa format=msf, mode=msa format=blc, mode=batch format=fasta\n"
			+ " \n"
			+ "\n"
			+ "  3.\n"
			+ "    To check JPred job status do:\n"
			+ "       'perl jpredapi status jobid=id [getResults=yes] [checkEvery=60] [silent]'\n"
			+ "    where:\n"
			+ "       'job=jobid' - jobid is JPred job id returned on submission\n"
			+ "       'getResults=yes' - if job successful jpredapi will download job results archive when ready (it is default, so, parameter could be left out)\n"
			+ "       'checkEvery=60' - how often to check for job status in seconds (default 60 seconds = 1 min, minimum is 10 seconds) - it is optional parameter, you may leave it out, script will take care of it\n"
			+ "                       NOTE: if using 'checkEvery=once' the program will perform status check just once and exit\n"
			+ "       'silent' - adding the word 'silent' to the command line will suppress all but essential output\n"
			+ "\n"
			+ "  3.1      \n"
			+ "    Check one_job_retrieval.csh script file provided. One can use it to retrieve JPred job results like so:\n"
			+ "       'source one_job_retrieval.csh jobId' - where jobId is the JPred job id returned at submission (id looks like: jp_OpHCA0J)\n"
			+ "\n"
			+ "\n"
			+ "  4.\n"
			+ "    To check how many jobs you have already submitted on a given day (out of 1000 maximum allowed jobs per user per day) do:\n"
			+ "        'perl jpredapi quota email=name\\@domain.com'\n"
			+ "    where: \n"
			+ "	'email=name\\@domain.com' - defines email address you use for job submissions\n"
			+ "\n"
			+ "  5.\n"
			+ "    To check how much time (in sec) left before more jobs are allowed from a given user (limit is 1000 jobs per user per day) do:\n"
			+ "        'perl jpredapi sectonewday'\n"
			+ "\n"
			+ "END\n"
			+ "    print $doc;\n"
			+ "}\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "my $silent = 0;\n"
			+ "subcommand 'submit' => sub {\n"
			+ "    my ($file,$mode,$format,$skipPDB,$email,$name,$seq) = ('defaultNotDefined','defaultNotDefined','defaultNotDefined','on','defaultNotDefined','defaultNotDefined','defaultNotDefined'); \n"
			+ "    my $paramsLine = '';\n"
			+ "    my $delim = '£€£€';\n"
			+ "    my $n = scalar @ARGV;\n"
			+ "    \n"
			+ "    my $formatUser;\n"
			+ "    for (my $i=0; $i<$n; $i++) {\n"
			+ "	my $a = $ARGV[$i];\n"
			+ "	if ($a =~ /^(.*)=(.*)$/) {\n"
			+ "	    my $key=$1;\n"
			+ "	    my $val=$2;\n"
			+ "	    if ($key eq 'file') {$file = $val;}\n"
			+ "	    if ($key eq 'mode') {$mode = $val;}\n"
			+ "	    if ($key eq 'format') {$formatUser = $val;}# $paramsLine = $paramsLine.$a.$delim;}\n"
			+ "	    if ($key eq 'skipPDB') {$skipPDB = $val; $paramsLine = $paramsLine.$a.$delim;}\n"
			+ "	    if ($key eq 'email') {$email = $val; $paramsLine = $paramsLine.$a.$delim;}\n"
			+ "	    if ($key eq 'name') {$name = $val; $paramsLine = $paramsLine.$a.$delim;}\n"
			+ "	    if ($key eq 'seq') {$seq = $val;}	    \n"
			+ "	}\n"
			+ "	if ($a eq 'silent') {$silent=1;}\n"
			+ "    }     \n"
			+ "    if (!($paramsLine =~ /skipPDB/)){$paramsLine = $paramsLine.'skipPDB='.$skipPDB.$delim;}\n"
			+ "    if ( ($formatUser eq 'raw' && $mode eq 'single') \n"
			+ "	 || ($formatUser eq 'fasta' && $mode eq 'single') \n"
			+ "	 || ($formatUser eq 'fasta' && $mode eq 'msa') \n"
			+ "	 || ($formatUser eq 'msf' && $mode eq 'msa') \n"
			+ "	 || ($formatUser eq 'blc' && $mode eq 'msa') \n"
			+ "	 || ($formatUser eq 'fasta' && $mode eq 'batch') \n"
			+ "	) {\n"
			+ "	if ($formatUser eq 'raw' && $mode eq 'single') {$format = 'seq';}\n"
			+ "	if ($formatUser eq 'fasta' && $mode eq 'single') {$format = 'seq';}\n"
			+ "	if ($formatUser eq 'fasta' && $mode eq 'msa') {$format = 'fasta';}\n"
			+ "	if ($formatUser eq 'msf' && $mode eq 'msa') {$format = 'msf';}\n"
			+ "	if ($formatUser eq 'blc' && $mode eq 'msa') {$format = 'blc';}\n"
			+ "	if ($formatUser eq 'fasta' && $mode eq 'batch') {$format = 'batch';}\n"
			+ "	$paramsLine = $paramsLine.'format='.$format.$delim;\n"
			+ "    } else {\n"
			+ "	print \"ERROR: Invalid mode/format combination. Valid combinations are:\\nmode=single format=raw\\nmode=single format=fasta\\nmode=msa format=fasta\\nmode=msa format=msf\\nmode=msa format=blc\\nmode=batch format=fasta\\n...Exiting.\\n\";\n"
			+ "        exit();\n"
			+ "    }\n"
			+ "    if ($file eq 'defaultNotDefined' && $seq eq 'defaultNotDefined') {\n"
			+ "	print \"ERROR: Neither input sequence nor input file defined. Exiting.\\n\";\n"
			+ "	exit();\n"
			+ "    }\n"
			+ "    if ($file ne 'defaultNotDefined' && $seq ne 'defaultNotDefined') {\n"
			+ "        print \"ERROR: Both input file and sequence defined. Please choose one or the other. Exiting.\\n\";\n"
			+ "        exit();\n"
			+ "    }\n"
			+ "    if ($seq ne 'defaultNotDefined' && $format ne 'seq') {\n"
			+ "        print \"ERROR: when sequence is defined like so 'seq=AABBCC' format has to be 'seq'. Exiting.\\n\";\n"
			+ "        exit();\n"
			+ "    }\n"
			+ "    if ($email eq 'defaultNotDefined') {\n"
			+ "	if (!$silent) {print \"NOTE: email is not defined. Please consider using email for next submission (see documentation for details on why using email).\\n\";}\n"
			+ "    }\n"
			+ "    if ($email eq 'defaultNotDefined' && $format eq 'batch') {\n"
			+ "	print \"ERROR: when submitting batch job email is obligatory (you will receive detailed report, list of links and a link to archive to all results via email. Exiting.\\n)\";\n"
			+ "	exit();\n"
			+ "    }\n"
			+ "    if ( !($skipPDB eq 'on' || $skipPDB eq 'off') ) {\n"
			+ "	print \"ERROR: skipPDB parameter values could only be 'on' (skip PDB check, default) or 'off' (perform PDB check). Exiting.\\n\";\n"
			+ "	exit();\n"
			+ "    } \n"
			+ "    if ( !($name =~ /^\\w+$/) ) {\n"
			+ "	print \"ERROR: name parameter could only be built from Latin characters, numbers, and '_' symbol. Exiting.\\n\";\n"
			+ "	exit();\n"
			+ "    }\n"
			+ "\n"
			+ "    if (!$silent) {\n"
			+ "	print \"Your job will be submitted with the following parameters:\\n\";\n"
			+ "	if ($file ne 'defaultNotDefined') {print \"file: $file\\n\";}\n"
			+ "	if ($seq ne 'defaultNotDefined') {print \"seq: $seq\\n\";}\n"
			+ "	print \"format: $format\\n\";\n"
			+ "	print \"skipPDB: $skipPDB\\n\";\n"
			+ "	if ($email ne 'defaultNotDefined') {print \"email: $email\\n\";}\n"
			+ "	if ($name ne 'defaultNotDefined') {print \"name: $name\\n\";}\n"
			+ "	#print \": $\\n\";\n"
			+ "    }\n"
			+ "\n"
			+ "    my $resource;\n"
			+ "    if ($file ne 'defaultNotDefined') {\n"
			+ "	open( INPUT, $file) or die \"ERROR:\\tFile $file does not exist.\\n\";\n"
			+ "	while ( my $line = <INPUT> ) {\n"
			+ "	    $resource .= $line;\n"
			+ "	}\n"
			+ "	close(INPUT);\n"
			+ "    }\n"
			+ "    if ($seq ne 'defaultNotDefined') {\n"
			+ "	$resource .= \">query\\n\".$seq;\n"
			+ "    }\n"
			+ "    $resource = $paramsLine.$resource;\n"
			+ "\n"
			+ "    #print \"RESOURCE:\\n$resource\\n\";\n"
			+ "\n"
			+ "    my $response = $ua->request(POST HOST.'/job', \n"
			+ "				'Content-Type' => 'text/txt',\n"
			+ "				Content        => $resource\n"
			+ "	);\n"
			+ "    # On success\n"
			+ "    if ($response->is_success) {\n"
			+ "	if ($format ne 'batch') {\n"
			+ "	    my $url;	\n"
			+ "	    $url = $response->header('Location');\n"
			+ "	    my ($id) = $url =~ /(jp_.*)$/;\n"
			+ "	    if ($id) {\n"
			+ "		if (!$silent) {\n"
			+ "		    print \"\\n\\nCreated JPred job with jobid: $id\\n\";\n"
			+ "		    print \"You can check the status of the job using the following URL: $url\\n\";\n"
			+ "		    print \"...or using 'perl jpredapi status jobid=$id getResults=yes checkEvery=60 silent' command\\n\";\n"
			+ "		    print \"(Check documentation for more details.)\\n\";\n"
			+ "		} else {\n"
			+ "		    print \"Created JPred job with jobid: $id\\n\";\n"
			+ "		}\n"
			+ "	    } else {\n"
			+ "		print \"\\n\\nERROR: \";\n"
			+ "		print $response->content;\n"
			+ "		print \"\\n\\n\";\n"
			+ "	    }\n"
			+ "	} \n"
			+ "	if ($format eq 'batch') {\n"
			+ "	    my $message = $response->content;# =~ m{<h1>([^<]+)</h1>};\n"
			+ "	    $message =~ s/^<h1>\\s+|<\\/h1>$//g;\n"
			+ "	    print \"$message\\n\";\n"
			+ "	}\n"
			+ "    }\n"
			+ "    # On failure, barf\n"
			+ "    else {\n"
			+ "        barf $response;\n"
			+ "    }\n"
			+ "\n"
			+ "};\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "#perl jpredapi status jobid=id [getResults=yes] [checkEvery=60] [silent]\n"
			+ "subcommand 'status' => sub {\n"
			+ "    my ($id,$interval,$getResults,$silent) = ('defaultNotDefined',60,'yes',0);\n"
			+ "    my $n = scalar @ARGV;\n"
			+ "        \n"
			+ "    for (my $i=0; $i<$n; $i++) {\n"
			+ "	my $a = $ARGV[$i];\n"
			+ "	if ($a =~ /^(.*)=(.*)$/) {\n"
			+ "	    my $key=$1;\n"
			+ "	    my $val=$2;\n"
			+ "	    if ($key eq 'jobid') {$id = $val;}\n"
			+ "	    if ($key eq 'getResults') {$getResults = $val;}\n"
			+ "	    if ($key eq 'checkEvery') {$interval = $val;}\n"
			+ "	}\n"
			+ "	if ($a eq 'silent') {$silent=1;}\n"
			+ "    }     \n"
			+ "\n"
			+ "    if (!$silent) {\n"
			+ "	print \"Your job status will be checked with the following parameters:\\n\";\n"
			+ "	print \"JobId: $id\\n\";\n"
			+ "	print \"getResults: $getResults\\n\";\n"
			+ "	print \"checkEvery: $interval [sec]\\n\";\n"
			+ "    }\n"
			+ "\n"
			+ "    my $jobDoneFlag = 0;\n"
			+ "    my $jobDoneFlagExtra = 0;\n"
			+ "    do {\n"
			+ "	my $now_string = localtime;\n"
			+ "	print \"$now_string\\t--->\\t\";\n"
			+ "	my $response = $ua->request(GET HOST.'/job/id/'.$id);\n"
			+ "	# On success\n"
			+ "	if ($response->is_success) {\n"
			+ "	    print $response->content;\n"
			+ "	    print \"\\n\";\n"
			+ "\n"
			+ "	    if ($response->content =~ /finished/) {\n"
			+ "		if ($getResults eq \"yes\") {\n"
			+ "		    if (!$silent) {print \"Will attempt to download results now (using 'wget') from:\\n\";}\n"
			+ "		    my $arcURL = JPRED4.\"/results/$id/$id.tar.gz\";\n"
			+ "		    if (!$silent) {print \"$arcURL\\n\\n\";}\n"
			+ "		    system(\"mkdir $id\");\n"
			+ "		    system(\"wget -o $id/download.log $arcURL\");\n"
			+ "		    system(\"mv $id.tar.gz $id/.\");\n"
			+ "		    print \"Job results archive is now available at: $id/$id.tar.gz\\n\";\n"
			+ "		}\n"
			+ "		$jobDoneFlag = 1;\n"
			+ "	    }\n"
			+ "	    if ($response->content =~ /malformed/) {$jobDoneFlag = 1;}\n"
			+ "	    if ($response->content =~ /does not exist in the queue/) {$jobDoneFlag = 1;}\n"
			+ "	    if ($response->content =~ /No job of that ID/) {$jobDoneFlagExtra++;}\n"
			+ "	    if ($jobDoneFlagExtra > 2) {$jobDoneFlag = 1;}\n"
			+ "	    #if ($response->content =~ //) {$jobDoneFlag = 1;}\n"
			+ "	}\n"
			+ "	# On failure, barf\n"
			+ "	else {\n"
			+ "	    barf $response;\n"
			+ "	    $jobDoneFlag = 1;\n"
			+ "	}\n"
			+ "	if ($jobDoneFlag || $interval eq 'once') {exit();}\n"
			+ "	sleep($interval);\n"
			+ "    } while (!($jobDoneFlag));\n"
			+ "\n"
			+ "};\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "subcommand 'quota' => sub {\n"
			+ "    my $n = scalar @ARGV;\n"
			+ "    my $email;\n"
			+ "    for (my $i=0; $i<$n; $i++) {\n"
			+ "	my $a = $ARGV[$i];\n"
			+ "	if ($a =~ /^(.*)=(.*)$/) {\n"
			+ "	    my $key=$1;\n"
			+ "	    my $val=$2;\n"
			+ "	    if ($key eq 'email') {$email = $val;}\n"
			+ "	}\n"
			+ "    }     \n"
			+ "    \n"
			+ "    my $response = $ua->request(GET HOST.'/quota/'.$email);\n"
			+ "    if ($response->is_success) {\n"
			+ "	print $response->content;\n"
			+ "    }\n"
			+ "};\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "\n"
			+ "subcommand 'sectonewday' => sub {\n"
			+ "    my $response = $ua->request(GET HOST.'/sectonewday');\n"
			+ "    if ($response->is_success) {\n"
			+ "        print $response->content;\n"
			+ "    }\n"
			+ "};\n"
			+ "\n"
			+ "";
	
	public static void main(String[] args) {
		DirectoryManager.verifyFolder(DirectoryManager.FILES);
		DirectoryManager.verifyFolder(DirectoryManager.FILES_PREDICT);
		DirectoryManager.verifyFolder(DirectoryManager.FILES_PREDICT_JPRED);
		writeFileLines(JPRED_FILENAME, JPRED_SCRIPT);
	}
}
